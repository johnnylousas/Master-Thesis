%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%                                                                      %
%     File: Thesis_Introduction.tex                                    %
%     Tex Master: Thesis.tex                                           %
%                                                                      %
%     Author: Andre C. Marta                                           %
%     Last modified :  2 Jul 2015                                      %
%                                                                      %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\newcommand{\SubItem}[1]{
	{\setlength\itemindent{15pt} \item[-] #1}
}

\chapter{Introduction}
\label{chapter:introduction}

In this chapter, the motivation behind the work is introduced, as well as the problem and the objectives to be achieved. 



%%%%%%%%%%%%%%%%%%



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Motivation}
\label{section:motivation}



Given the complexity of modern software systems, it is increasingly crucial to maintain quality and reliability, in a time-saving and cost-effective manner, specially in large and fast-paced companies. This is why many industries adopt a \textit{Continuous Integration} (CI) strategy, which is a popular software development technique where engineers, frequently, incorporate code changes into the mainline codebase, allowing them to easily check that their code can build successfully and pass tests across various system environments \cite{santolucito2018statically}  . The latter task performed in the process is called \textit{regression testing}. To ensure that the introduction of new features or the fix of known failures not only are correct, but also do not obstruct existing functionalities. Ergo, regression testing plays a fundamental role on certifying that newer versions adhere to the mainline.  
Regression can have many origins, namely code does not compile, performance drops or tests fail, and, as software teams grow, due to the rising amount of changes , the probability that one  creates a conflict is significant. Identifying and amending such regressions constitute one of the most challenging, costly and time-consuming tasks in the software development life-cycle \cite{Ziftci}.
In the last decades, there has been a high demand for automated techniques that accelerate early fault detection, minimizing human intervention. Regression test prioritization lies at the core of these techniques, as one of the most thriving fields in achieving promising results, with increasing research attention. Aiming to find the optimal permutation of ranked tests that match a certain criteria, i.e. the ability to detect faults \text{a priori}, the likelihood a change has of being merge or a limited time-frame  \cite{palma}. 
The automation process is accomplished through developing algorithms that are, traditionally, programmed for a certain objective, by obeying a set of well-defined instructions. Many traditional algorithms may have shortcomings and not scale well with the complexity of today's systems. However, in recent years, the field of Artificial Intelligence as been expanding at an astounding pace, fueled by the growth of computer power and the amount of available data. In particular, there is a trend in capitalizing machine learning (ML) algorithms and data-driven approaches to solve these kind of problems  \cite{durelli} . Concretely, in a supervised learning task, given a code change and a list of test cases to be prioritized, test cases can be classified as "pass" or "fail", depending on some set of features and use the result to rank failing tests first.
In fact, Catal \cite{catal} showed that ML approaches can improve the probability of fault detection, when compared to classic software algorithms. 
Powerful results have been achieved by several authors: Chen et al. \cite{chen} use semi-supervised K-Means to cluster test cases and then pick a small subset of tests from each cluster, Uber developers \cite{Uber} built a speculation engine powered by Logistic regression to predict failed test cases and more recently, Palma et al. \cite{palma} combined traditional test and similarity-based quality metrics, and Lachmann et al. \cite{lachmannlp} resorted to textual information to extract features from test descriptions written in Natural Language.
 

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Objectives}
\label{section:objectives}
The objectives delineated for this work are:
\begin{itemize}
	\item Detect common usage patterns, in a controlled environment, by generating synthetic data.
	\SubItem{Learn heuristics to automate fault detection process}
	\item Optimize regression testing systems using real world data.
	\SubItem{Analyse how different system configurations affect Continuous Integration}
	\SubItem{Reduce fault detection time}
	\SubItem{Provide a Live-Estimate of the Status of a Project}
	\SubItem{Given a commit, choose which chain of tests minimize pass/fail uncertainty}
\end{itemize}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{Problem}
\label{section:repository}

trade off speed vs. correctness, thats the problem.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Thesis Outline}
\label{section:outline}

Briefly explain the contents of the different chapters...


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{Repository}
\label{section:repository}

Provide an overview of the topic to be studied...